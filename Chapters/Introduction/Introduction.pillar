!!Introduction

!!!Rational
@ch:ngRational

The idea behind FamixNG is to allow the creation of meta-models by composing basic entities rather than using single inheritance.

Take for example a simple model with Classes and Methods. A Class has a ''name'' and ''contains'' methods. A Method has a ''name''. We can create a simple hierarchy:

+figures/intro1.png|label=simpleHierarchy++figures/intro1.png|label=simpleHierarchy+

However, if we introduce AnonymousClass we have a problem, it is a Class (thus a ContainerEntity, but it is not Named).
With composition, we could say that there are named entities (that have a name) and there are container entities (that contain other entities). A Class is composed of NamedEntity and ContainerEntity, an AnonymousClass is a composition of ContainerEntity, and a Method is a composition of NamedEntity.

FamixNG offers a collection of fundamental concepts (NamedEntities, ScopingEntities...) and a better mechanism to handle bi-directional associations to simplify the creation of new meta-models.

!!!General Organisation
@ch:ngPhilosophy

The composition is implemented using Pharo (stateful) traits, and the concepts of the meta-model are implemented using Pharo classes.
A new metamodel is generated using a *@Builder>ch:Builder* by telling it how the new concepts are composed and what are their relationships.

The FamixNG provides all fundamental concepts as a library of traits. When you create a custom meta-model, you compose the entities of your meta-models (represented by classes) from these traits. You may want to create own traits if you require reusability of a concept they provide.

In the most basic usages, one should be able to create a new meta-model by composing the existing fundamental concepts without the need to create new ones.

!!!Catalog of Concepts
@ch:ngCatalog

-TAnnotationInstance
-TInvocation
-TEnumValue
-TWithImplicitVariables
-TFunction
-TCompilationUnit
-TAccessible
-TWithAttributes
-TWithTypes
-TType
-TException
-TPackage
-TAccess
-TWithModule
-TSub
-TWithNamespaces
-TWithThrownExceptions
-TTemplateUser
-TWithMethods
-TWithReferences
-TModule
-TWithAnnotationInstanceAttributes
-TWithComments
-TSourceLanguage
-TImplicitVariable
-TTypeAlias
-TWithAnnotationTypes
-TWithTemplates
-TWithSourceLanguage
-TPreprocessorIfdef
-TWithPackages
-TReference
-TFileAnchor
-TLocalVariable
-TWithSuperInheritances
-TParameter
-TWithTypeAliases
-TPackageable
-TSubInheritance
-TWithFunctions
-TWithParameterizedTypeUsers
-TSuperInheritance
-TWithDeclaredExceptions
-TNamespaceEntity
-TTypedAnnotationInstanceAttribute
-TWithFileInclude
-TNamespace
-TTypedStructure
-TWithHeader
-TWithParameterizedTypes
-TAttribute
-TInvocationsReceiver
-TWithInvocations
-TComment
-TWithClassScope
-TWithAnnotationInstances
-TWithAccesses
-TInvocable
-TWithCompilationUnit
-TWithSourceAnchor
-TWithSubInheritances
-TAssociation
-TThrownException
-TWithDereferencedInvocations
-TTemplate
-TWithTypedStructures
-TParameterizedType
-TFileInclude
-TWithModifiers
-TSuper
-TWithSignature
-TGlobalVariableScope
-TAnnotationType
-TFile
-TAnnotationTypeAttribute
-TWithParameters
-TWithFiles
-TWithTrait
-TScopingEntity
-TSourceAnchor
-TDeclaredException
-TPreprocessorDefine
-TWithLocalVariables
-THeader
-TTrait
-TWithEnumValues
-TCaughtException
-TAnnotationInstanceAttribute
-TMethod
-TGlobalVariable
-TReferenceable
-TParameterizedTypeUser
-TNamed
-TWithExceptions
-TTypedAnnotationInstance
-TWithCaughtExceptions
-TDereferencedInvocation
